#### JS闭包
* 闭包的产生
在一个嵌套结构中，当内部子函数引用了外部父函数的变量（函数）时，就产生了闭包（闭包存在于嵌套的内部函数中）。<font color="red">在嵌套结构的内部函数定义执行完成时就产生了，不是在调用时产生了。当包含闭包的函数对象成为垃圾对象时闭包死亡</font>
* 产生闭包的条件
    1. 存在函数嵌套
    2. 内部子函数引用了外部函数的数据（变量/函数）
    3. 外部函数执行调用（内部函数不需要被调用）
* 常见的闭包
    1. 将函数作为另一个函数的返回值
    ```
    function fn1(){
        //此时闭包已经产生（函数提升，内部函数对象已经创建了）
        var a = 2
        function fn2(){
            a++
            console.log(a)
        }
        return fn2
    }
    var f = fn1()
    f()//3
    f()//4
    ```
    2. 将函数作为实参传递给另一个函数调用
* 闭包的作用
    1. 使函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的声明周期）
    2. 让函数外部的操作可以访问（读写）函数内部的数据（变量/函数）
    闭包定义一个JS模块，可以选择性的向外暴露某个方法的对象或者函数，模块的使用者只需要调用模块暴露的方法即可实现相应的功能
* 闭包的缺点和解决方法
    * 缺点
        1. 函数执行完成后，函数内的局部变量没有释放，占用内存时间会变长
        2. 容易造成内存泄漏
    * 解决方法
        1. 少使用闭包
        2. 及时的释放
    ```
    function fn1(){
        var arr = new Array[100000]
        function fn2(){
            console.log(arr.length)
        }
        return fn2
    }
    var f = fn1()
    f()
    f = null//让内部函数称为垃圾对象，系统会自动回收该部分闭包
    ```
* 闭包所造成的内存溢出和内存泄漏
    * 内存溢出
        1. 一种程序运行出现的错误
        当程序运行需要的内存超出剩余内存时，就会抛出内存溢出的错误
    * 内存泄漏
    占用的内存没有及时释放，内存泄漏积累太多会导致内存溢出
    * 常见的内存泄漏
        1. 意外的全局变量
        2. 没有及时清理定时器或者回调函数
        3. 闭包
    
