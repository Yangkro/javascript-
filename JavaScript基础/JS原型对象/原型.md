#### 原型prototype
我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype，每一个函数的prototype不相同，其地址指向原型对象，原型对象相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，<font color="red">我们可以将原型对象中的共有内容，统一设置到原型对象中</font>
如果函数作为普通函数调用prototype将没有任何作用；<font color="red">当函数以构造函数调用时，他所创建的对象中都会有一个隐含属性指向构造函数的原型对象，我们可以通过__proto__来访问该属性</font>当我们访问对象的一个属性或者方法时，它会优先在自身对象中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到也可以直接使用，<font color="red">以后我们创建对象时可以将这些对象**共有**的属性和方法，统一添加到构造函数的原型对象中</font>
* 使用in检查对象中的某个属性时，如果实例中没，对象的原型中有，也会返回true。<font color="red">可以使用对象中的hasOwnProperty()来检查对象中是否含有该属性</font>
* 原型链
原型也是对象，所以它也有原型，当我们使用一个属性或者方法时，会先在类的自身中寻找，如果有，则直接使用；如果没有则去原型对象中寻找，如果原型对象中有，则使用；如果没有则去原型对象类的原型对象中寻找，如果有则使用，直至找到Object对象原型，如果还没有找到则返回undefined（Object对象原型没有原型）
    ```
    
    function Student(name, age, gender){
        this.name = name;
        this.age = age;
        this.gender = gender;
        // this.sayName = sayName;进行改进
        }

	// function sayName(){
	// 	console.log("hello I'm "+this.name);
	// }
	function Teacher(name, age, gender){
		this.name = name;
		this.age = age;
		this.gender = gender;
		}
	var stu1 = new Student("Tom", 18, "male");
	var stu2 = new Student("Marry", 18, "famale");
	stu2.grade = "2019级";
	var stu3 = new Student();
	console.log(stu1 == stu2);//false
	//向prototype中添加属性
	Student.prototype.grade = "2020级";
	//向原型对象中添加公共方法
	Student.prototype.sayHello = function(){
		console.log(("hello"));
		}
	//添加公共方法sayName
	Student.prototype.sayName = function(){
	console.log("hello I'm "+this.name);
	    }
	//不要写成Student().prototype，类和函数要区分开
	console.log(Student.prototype);
	//不同函数的公共原型对象不同，因为地址不同
	console.log(Student.prototype == Teacher.prototype);
	//相同对象的实例的__proto__地址相同，所以判等为true
	console.log(stu1.__proto__ == stu2.__proto__);//true
	console.log(Student.prototype.grade);
	console.log(Student.grade);//undefined，不可以通过类直接访问
	console.log(stu1.grade);//可以直接访问，满足就近原则
	console.log(stu2.grade);//会优先在自己的作用域中寻找，没有的话再去公共原型对象中
	console.log(stu2.sayName());
    console.log("grade" in stu3);//true 对象中没有，但是原型对象中，所有true
    console.log(stu3.hasOwnProperty("name"));//true
    console.log(stu3.hasOwnProperty("sayHello"));//false
    console.log("原型对象中有sayHello属性"+stu3.__proto__.hasOwnProperty("sayHello"));
    console.log(stu3.__proto__.hasOwnProperty("hasOwnProperty"));//false
    //原型的原型中查找属性
	console.log(stu3.__proto__.__proto__.hasOwnProperty("hasOwnProperty"));//true
    ```
